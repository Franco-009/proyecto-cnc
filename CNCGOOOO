#include <Stepper.h>

/////////////////////// CONFIGURACI√ìN MOTORES ///////////////////////
// NEMA 17 - Ejes X y Y
#define DIR_X 27
#define STEP_X 14

#define DIR_Y 25
#define STEP_Y 26

// 28BYJ-48 - Eje Z (sube/baja l√°piz)
#define IN1 4
#define IN2 0
#define IN3 2
#define IN4 15
Stepper motorZ(2048, IN1, IN3, IN2, IN4);  // orden correcto para ULN2003

/////////////////////// FINALES DE CARRERA ///////////////////////
#define ENDSTOP_X 34   // Final de carrera eje X
#define ENDSTOP_Y 35   // Final de carrera eje Y

// Configuraci√≥n b√°sica
const float mmPorPaso_X = 0.05; // calibrar seg√∫n tu mec√°nica
const float mmPorPaso_Y = 0.05; // calibrar seg√∫n tu mec√°nica
const int pasosPorVueltaZ = 2048;

// Velocidad base
const unsigned int velNema = 600; // microsegundos entre pasos - ESTA ES LA VELOCIDAD PAPA
int velocidadZ = 15;              // en RPM

// Posici√≥n actual del cabezal
float posX = 0, posY = 0, posZ = 0;

/////////////////////// SETUP ///////////////////////
void setup() {
  Serial.begin(115200);
  Serial.println("Mini CNC ESP32 listo con finales de carrera!");

  pinMode(DIR_X, OUTPUT);
  pinMode(STEP_X, OUTPUT);
  pinMode(DIR_Y, OUTPUT);
  pinMode(STEP_Y, OUTPUT);

  pinMode(ENDSTOP_X, INPUT_PULLUP);
  pinMode(ENDSTOP_Y, INPUT_PULLUP);

  motorZ.setSpeed(velocidadZ);
}

/////////////////////// FUNCIONES DE MOVIMIENTO ///////////////////////

void moverEje(int dirPin, int stepPin, bool sentido, int pasos, int endstopPin) {
  digitalWrite(dirPin, sentido ? HIGH : LOW);

  for (int i = 0; i < pasos; i++) {
    // Si est√° yendo hacia el origen, detener si el final de carrera se activa
    if (!sentido && digitalRead(endstopPin) == LOW) {
      Serial.println("‚ö†Ô∏è  Final de carrera alcanzado!");
      break;
    }

    digitalWrite(stepPin, HIGH);
    delayMicroseconds(velNema);
    digitalWrite(stepPin, LOW);
    delayMicroseconds(velNema);
  }
}

void moverX(float distanciaMM) {
  int pasos = abs(distanciaMM / mmPorPaso_X);
  bool sentido = distanciaMM > 0;
  moverEje(DIR_X, STEP_X, sentido, pasos, ENDSTOP_X);
  posX += distanciaMM;
}

void moverY(float distanciaMM) {
  int pasos = abs(distanciaMM / mmPorPaso_Y);
  bool sentido = distanciaMM > 0;
  moverEje(DIR_Y, STEP_Y, sentido, pasos, ENDSTOP_Y);
  posY += distanciaMM;
}

void moverZ(float distanciaMM) {
  Serial.println("Moviendo motor z");
  int pasos = abs(distanciaMM * 1024 / 2); // cada 2 cm aprox.
  if (distanciaMM > 0) motorZ.step(pasos);
  else motorZ.step(-pasos);
  posZ += distanciaMM;
}

/////////////////////// HOMING ///////////////////////
void hacerHome() {
  Serial.println("üè† Haciendo homing...");

  // Ir hacia atr√°s hasta activar los finales
  while (digitalRead(ENDSTOP_X) == HIGH) {
    digitalWrite(DIR_X, LOW);
    digitalWrite(STEP_X, HIGH);
    delayMicroseconds(velNema);
    digitalWrite(STEP_X, LOW);
    delayMicroseconds(velNema);
  }

  while (digitalRead(ENDSTOP_Y) == HIGH) {
    digitalWrite(DIR_Y, LOW);
    digitalWrite(STEP_Y, HIGH);
    delayMicroseconds(velNema);
    digitalWrite(STEP_Y, LOW);
    delayMicroseconds(velNema);
  }

  posX = 0;
  posY = 0;
  posZ = 0;

  Serial.println("‚úÖ Homing completo!");
}

/////////////////////// PARSER DE COMANDOS ///////////////////////

void interpretarComando(String cmd) {
  cmd.trim();
  cmd.toUpperCase();

  if (cmd.startsWith("G0") || cmd.startsWith("G1")) { // Movimiento
    float x = NAN, y = NAN, z = NAN;

    int ix = cmd.indexOf('X');
    int iy = cmd.indexOf('Y');
    int iz = cmd.indexOf('Z');

    if (ix != -1) x = cmd.substring(ix + 1).toFloat();
    if (iy != -1) y = cmd.substring(iy + 1).toFloat();
    if (iz != -1) z = cmd.substring(iz + 1).toFloat();

    if (!isnan(x)) moverX(x);
    if (!isnan(y)) moverY(y);
    if (!isnan(z)) moverZ(z);

    Serial.printf("Posici√≥n actual: X=%.2f Y=%.2f Z=%.2f\n", posX, posY, posZ);
  }
  else if (cmd.startsWith("HOME")) {
    hacerHome();
  }
  else {
    Serial.println("Comando desconocido");
  }
}

/////////////////////// LOOP PRINCIPAL ///////////////////////
void loop() {
  if (Serial.available()) {
    String comando = Serial.readStringUntil('\n');
    interpretarComando(comando);
  }

  // moverZ(60.00);
}
